defun gcd :: a, b => ?(
    a             | b == 0,
    gcd(b, a % b) | ...
)

defun gcd :: a, b => ?( a | b == 0, gcd(b, a % b) | ...)
defun fact :: n => 1 if n == 1 else n * fact(n - 1)
defun fact :: n => ?( 1 | n == 1, n * fact(n - 1) * n | ...)

defun plus :: a, b => a + b
fun :: a => fun :: b, c => a + b + c

def (a = 2, b = 3)
let a = 3 in a + a

(fun :: x => x)(1)
(fun :: a, b => a + b)(1, 2)
(fun :: a => fun :: b => a + b)(1, 2)
?(a | a == 2, b | a == 1, c | a == 0, d | ...)
(let a, b = 1, 2 in fun :: x => a + b + x)(1)

def Y = fun :: f => (fun :: x => f(x(x)))(fun :: x => f(x(x)))

let fact = fun :: n => ?( 1 | n == 1, n * fact(n - 1) | ...) in fact(2)
let factplusx = fun :: n, x => ?(1 + x | n == 1 , factplpusx(n - 1, x) * n + x | ...)) in factplusx(2, 2)
let fact = Y(fun :: f => fun :: n => ?(1 | n == 1 , f(n - 1) * n | ...)) in fact(3)
let factplusx = Y(fun :: f => fun :: n, x => ?(1 + x | n == 1 , f(n - 1, x) * n + x | ...)) in factplusx(2, 2)
let gcd = fun :: a, b => ?( a | b == 0, gcd(b, a % b) | ...) in gcd (14, 14)
let gcd = Y(fun :: f => fun :: a, b => ?( a | b == 0, f(b, a % b) | ...)) in gcd (1, 1)
def ack = fun :: m, n => ?( n + 1 | m == 0, ack(m - 1, 1) | n == 0, ack(m - 1, ack(m, n - 1))  | ...)

// not working

defun pair :: a, b, f => (f(a, b)); defun first :: a, b => a; defun second :: a, b => b